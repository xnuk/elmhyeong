module Parser exposing (..)

import Combine exposing (Parser, (<$>), fail, succeed, (>>=), (*>), (<*>), (<|>), runParser, while, manyTill, end)
import Combine.Char exposing (oneOf, char, satisfy)
import String exposing (filter, length, foldl, toList, cons)

type Inst = Push | Add | Mul | Neg | Inv | Swi
type Heart = FilledHeart Char | EmptyHeart | NoHeart | Question | Exclamation
type Token = Inst (Inst, Int) | Dot Int | Heart Heart | Dots (List Int)

while1 f = String.cons <$> satisfy f <*> while f

isHangul x = 'ê°€' <= x && x <= 'íž£'
filterHangulLen = String.length << String.filter isHangul

instSingle = oneOf ['í˜•','í•­','í•«','í£','í¡','í‘'] >>= \x -> case x of
    'í˜•' -> succeed (Push, 1)
    'í•­' -> succeed (Add, 1)
    'í•«' -> succeed (Mul, 1)
    'í£' -> succeed (Neg, 1)
    'í¡' -> succeed (Inv, 1)
    'í‘' -> succeed (Swi, 1)
    _ -> fail ""

instMany = oneOf ['í˜€', 'í•˜', 'í'] >>= \z -> case z of
    'í˜€' -> while ((/=) 'ì—‰')
        >>= \x -> (char 'ì—‰' *> succeed (Push, filterHangulLen x + 2))
    'í•˜' ->
        let f n = oneOf ['ì•™', 'ì•—'] >>= \c -> case c of
            'ì•™' -> succeed (Add, n)
            'ì•—' -> succeed (Mul, n)
            _ -> fail ""
        in while (\c -> not (c == 'ì•™' || c == 'ì•—'))
            >>= \x -> f (filterHangulLen x + 2)
    'í' ->
        let f n = oneOf ['ì', 'ì', 'ìœ½'] >>= \c -> case c of
            'ì' -> succeed (Neg, n)
            'ì' -> succeed (Inv, n)
            'ìœ½' -> succeed (Swi, n)
            _ -> fail ""
        in while (\c -> not (c == 'ì' || c == 'ì' || c == 'ìœ½'))
            >>= \x -> f (filterHangulLen x + 2)
    _ -> fail ""

inst = instSingle <|> instMany

dotLength = foldl (\c n -> (if c == '.' then 1 else 3) + n) 0

dot = while1 (\c -> c == '.' || c == 'â€¦' || c == 'â‹¯' || c == 'â‹®') >>= (succeed << dotLength)

filledHeart = oneOf (toList "â™¥â¤ðŸ’•ðŸ’–ðŸ’—ðŸ’˜ðŸ’™ðŸ’šðŸ’›ðŸ’œðŸ’") >>= (succeed << FilledHeart)

emptyHeart = char 'â™¡' *> succeed EmptyHeart

question = char '?' *> succeed Question
exclamation = char '!' *> succeed Exclamation

heart = filledHeart <|> emptyHeart <|> question <|> exclamation

dots = manyTill dot ((heart *> succeed ()))

parse = manyTill ((Dot <$> dot) <|> (Heart <$> heart)) end

run = runParser parse ()
